# ROLIŲ SISTEMOS PAAIŠKINIMAS - A-DIENYNAS

## Current Role vs Default Role - Paaiškinimas

### **Esmė ir problema:**

**A-DIENYNAS** sistema turi vartotojus, kurie gali turėti **kelias roles** vienu metu. Pvz., Saulius Anusas turi: `["manager", "student", "parent", "curator", "mentor"]`.

### **Dvi skirtingos rolės:**

#### 1. **`default_role`** (Numatytoji rolė)
- **Kas tai:** Rolė, kurią vartotojas pasirenka **nustatymuose** (settings)
- **Kada nustatoma:** Prisijungimo metu, pagal vartotojo pasirinkimą
- **Kur saugoma:** Backend duomenų bazėje (`users_user.default_role`)
- **Pavyzdys:** Saulius nustatė, kad pagal nutylėjimą prisijungia kaip "manager"

#### 2. **`current_role`** (Dabartinė rolė)
- **Kas tai:** Rolė, į kurią vartotojas **persijungė** eigos metu
- **Kada nustatoma:** Kai vartotojas paspaudžia rolės mygtuką įrankių juostoje
- **Kur saugoma:** Frontend localStorage (`current_role`)
- **Pavyzdys:** Saulius prisijungė kaip "manager", bet persijungė į "mentor"

### **Problema, kuri buvo:**

**Backend filtravimas** naudojo tik `default_role`:
```python
# SENAS KODAS - NETEISINGAS
current_role = user.default_role  # Visada "manager"
if current_role == 'mentor':      # Niekada nepasiekiama
    return Violation.objects.filter(created_by=user)
```

**Rezultatas:** Saulius visada matė visus violations, nes jo `default_role` yra "manager", net jei jis persijungė į "mentor".

### **Sprendimas:**

**Frontend perduoda dabartinę rolę** per API header:
```typescript
// Frontend - RoleSwitcher.tsx
const handleRoleSelect = (role: string) => {
  setCurrentRole(role);  // Išsaugo į auth store
  localStorage.setItem('current_role', role);  // Išsaugo API užklausoms
}
```

**API klientas perduoda rolę** per header:
```typescript
// Frontend - api.ts
api.interceptors.request.use((config) => {
  const currentRole = localStorage.getItem('current_role');
  if (currentRole) {
    config.headers['X-Current-Role'] = currentRole;  // Perduoda backend
  }
});
```

**Backend naudoja perduotą rolę**:
```python
# Backend - views.py
def get_queryset(self):
    # Pirmiausia patikrinti header iš frontend
    current_role = self.request.headers.get('X-Current-Role')
    
    # Jei nėra header, naudoti default_role
    if not current_role:
        current_role = user.default_role
    
    if current_role == 'mentor':  # Dabar veiks teisingai!
        return Violation.objects.filter(created_by=user)
```

### **Rezultatas:**

- **Saulius prisijungia** → `default_role = "manager"` → mato visus violations
- **Saulius persijungia į "Mentorius"** → `current_role = "mentor"` → mato tik savo violations
- **Saulius persijungia į "Kuratorius"** → `current_role = "curator"` → mato visus violations

### **Kodėl reikia abiejų:**

1. **`default_role`** - nustato, kaip vartotojas prisijungia pagal nutylėjimą
2. **`current_role`** - nustato, kokią rolę vartotojas naudoja dabar

**Esmė:** Backend turi žinoti ne tik, kokias roles turi vartotojas, bet ir **kokią rolę jis naudoja dabar**!

## TECHNINIS IMPLEMENTACIJOS APRAŠYMAS

### Frontend komponentai:

1. **useAuth hook** (`/frontend/src/hooks/useAuth.ts`):
   - Pridėtas `currentRole` state
   - Pridėti metodai `setCurrentRole()` ir `getCurrentRole()`
   - Išsaugo `currentRole` į localStorage API užklausoms

2. **RoleSwitcher** (`/frontend/src/components/ui/RoleSwitcher.tsx`):
   - Kai vartotojas pasirenka rolę, iškviečia `setCurrentRole()`
   - Išsaugo naują rolę į auth store ir localStorage

3. **API klientas** (`/frontend/src/lib/api.ts`):
   - Request interceptor prideda `X-Current-Role` header
   - Gauna `currentRole` iš localStorage

### Backend komponentai:

1. **ViolationViewSet** (`/backend/violation/views.py`):
   - `get_queryset()` metodas patikrina `X-Current-Role` header
   - Jei nėra header, naudoja `user.default_role`
   - Filtruoja violations pagal dabartinę rolę

### Duomenų srautas:

1. **Prisijungimas:**
   - Vartotojas prisijungia → `default_role` nustatomas
   - `currentRole` inicializuojamas su `default_role`

2. **Rolės keitimas:**
   - Vartotojas paspaudžia rolės mygtuką
   - `RoleSwitcher` iškviečia `setCurrentRole()`
   - Rolė išsaugoma į auth store ir localStorage

3. **API užklausa:**
   - API klientas prideda `X-Current-Role` header
   - Backend gauna header ir filtruoja duomenis

4. **Duomenų grąžinimas:**
   - Backend grąžina violations pagal dabartinę rolę
   - Frontend rodo tinkamus duomenis

## ROLIŲ FILTRAVIMO LOGIKA

### Manager (Sistemos valdytojas):
- Matо visus violations
- Pilnas sistemos valdymas

### Curator (Kuratorius):
- Matо visus violations
- Turinio valdymas ir moderavimas

### Mentor (Mentorius):
- Matо tik savo sukurtus violations
- Mokinių konsultavimas ir vedimas

### Parent (Tėvas/Globėjas):
- Matо tik savo vaikų violations
- Vaiko edukacinės veiklos stebėjimas

### Student (Studentas):
- Matо tik savo violations
- Mokymosi veiklos vykdymas

## FAILŲ SĄRAŠAS

### Pakeisti failai:

**Frontend:**
- `/frontend/src/hooks/useAuth.ts` - pridėtas currentRole state
- `/frontend/src/components/ui/RoleSwitcher.tsx` - atnaujintas rolės keitimas
- `/frontend/src/lib/api.ts` - pridėtas X-Current-Role header

**Backend:**
- `/backend/violation/views.py` - atnaujinta get_queryset() logika

### Testavimas:

1. Prisijunkite kaip Saulius Anusas (saulius.anusas@gmail.com)
2. Eikite į `/mentors/violations/management`
3. Patikrinkite, ar rodo tik 6 violations (kuriuos jis sukūrė)
4. Persijunkite į "Sistemos valdytojas" rolę
5. Patikrinkite, ar dabar rodo visus 10 violations

## IŠVADOS

Šis sprendimas užtikrina, kad:
- Vartotojai mato duomenis pagal savo dabartinę rolę
- Rolės keitimas veikia realiu laiku
- Backend teisingai filtruoja duomenis
- Sistema yra lanksti ir išplečiama

**Pagrindinis principas:** Frontend perduoda dabartinę rolę, backend ją naudoja filtravimui.
